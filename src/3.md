# Part 3 - Don't `panic`

This section will look at error handling in Rust, and also take a look at a few other things that you might have come accross already in more detail.

## Errors ([9](https://doc.rust-lang.org/book/ch09-00-error-handling.html))

Rust's error handling mechanisms are kind of unique. It draws a lot on functional languages here too, with the `Result<T, E>` type being used to represent possible errors that can reasonably be expected to be handled. Panics are the other error mechanism in Rust, and are used for unrecoverable errors that halt execution.

### Panics ([9.1](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html))

When something goes very very wrong in your program, and you can't really do anything about it, you panic. Rust has the `panic!()` macro, which prints an error message, unwinds and cleans up the stack, and then exits.

```rust
fn main() {
    panic!("uh oh");
}
```

See how our error message ends up being printed. By default, no backtrace is shown when code panics, but we can set the environment variabke `RUST_BACKTRACE=1` to. On your own machine, create a rust program that you know will panic, such as indexing out of bounds in an array, and run it with the environment variable set. You'll get a lot more information, especially when you're in debug mode. Printing the backtrace will help you pin down what is causing your code to panic.

### Results ([9.2](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html))

A lot of errors can be handled at runtime, which is what `Result<T, E>` is for.

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Result is generic over `T`, the type of the value returned upon success, and `E`, the type of the error value. Functions that return a `Result` expect you to handle possible error cases explicitly, whereas in other languages you may have to deal with exceptions. This makes error handling non-optional, meaning you're forced to write more robust code by design.

```rust
use std::{fs, io};
let f: Result<fs::File, io::Error> = fs::File::open("foo.txt");
println!("{f:?}"); //print the result
```

We can see in the above snippet that trying to open a non-existent file returns a result with either the file handle, or an I/O error. Since the code here is run on the Rust playground servers where `foo.txt` does not exist, the `Err(io::Error)` variant of the enum is printed, containing some information about the error.

There's a few different ways to deal with handling results. Pattern matching with `match` or `if let` is a good option, as then we can destructure the type to get the values we want out of it, and deal with the error however we want.

```rust
use std::{fs, io};
let f: Result<fs::File, io::Error> = fs::File::open("foo.txt");
match f {
    Ok(file) => println("File opened successfully!"),
    Err(_) => println("Could not open file, continuing..."),
}
```

We could also use `unwrap`, which panics if the `Result` is an `Err(E)`, and returns `T` if not. `expect` is the same, except we can specify an error message

```rust
use std::{fs, io};
let f: Result<fs::File, io::Error> = fs::File::open("foo.txt");

let file = f.expect("Could not open file");
```

We could also propagate the error back up to the caller. In functions that return a `Result<T, E>` or `Option<T>`, we can use the `?` operator to bubble the error back up, where the return type is compatible.

```rust
use std::{fs, io};
fn open_my_file() -> Result<String, io::Error>  {
    let contents: String = fs::read_to_string("foo.txt")?;
    Ok(contents)
}
```

Note that this only work if all the functions you use `?` on have the same return type as your function. Alternatively, you can return `Result<T, Box<dyn Err>>`, which allows you to return any error type that implements the the [`Error` trait](https://doc.rust-lang.org/std/error/trait.Error.html).

```rust
use std::{error::Error, fs};

fn do_fallible_things() -> Result<(), Box<dyn Error>> {
    let v = vec![45, 73, 12, 91];
    let sixth = v.get(6)?;
    let contents: String = fs::read_to_string("foo.txt")?;
    Ok(())
}
```

### Best Practices ([9.3](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html))

Getting use writing idiomatic error handling code in Rust can take a bit of practice. The general idea is to use the type system to your advantage where possible, and panic only where absolutely necessary.

`unwrap` and `expect` are handy when prototyping, before you decide on how you want to handle errors within your code. `unwrap` is also useful in cases where you have more information than the compiler, such as there being an invariant in your code that means the conditions for an error can never occur. `panic` should generally be used in cases where your code is in a bad state, and execution cannot continue under any circumstances

Results should be used where failure is an expected possibility, and the caller can be reasonably expected to handle them. It is often useful to create custom types that can be returned within `Result::Err(E)`, to describe the kinds of errors that may occur within your program. Encoding information within the type system makes your code more expressive and robust.

```rust
enum MyError {
    FileOpenError,
    FileTooLarge,
    FileParseError,
    NumberTooSmallError,
}

fn do_stuff() -> Result<u64, MyError> {
    let contents = std::fs::read_to_string("data.txt").map_err(|_| MyError::FileOpenError)?;

    if contents.len() > 10 {
        return Err(MyError::FileTooLarge);
    }

    let num: u64 = contents.parse().map_err(|_| MyError::FileParseError)?;
    num.checked_sub(100).ok_or(MyError::NumberTooSmallError)
}
```

Note how I'm making use of some of the methods of `Result` which make working with errors a lot nicer.

I want to shout out two crates here too that make error handling much nicer. [`Anyhow`](https://github.com/dtolnay/anyhow) provides a more ergonomic and flexible type for error handling. [`thiserror`](https://github.com/dtolnay/thiserror) provides a `#[derive]` macro for the `std::error::Error` trait, allowing you to create custom error types much more easily. Have a look at some examples of using the two to see how to structure code that works with errors nicely.

## Generic types ([10.1](https://doc.rust-lang.org/book/ch10-01-syntax.html))

Generics allow for [parametric polymorphism](https://en.wikipedia.org/wiki/Parametric_polymorphism) in Rust, letting us write type signatures that are generic over type variables. Generics can be used in struct/enum definitions:

```rust
struct Point<T> {
    x: T,
    y: T,
}

enum Option<T> {
    Some(T),
    None
}
```

And in function/method definitions:

```rust
fn id<T>(ty: T) -> T {
    ty
}

impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Self {x, y}
    }
}
```

Generics are [monomorphised](https://en.wikipedia.org/wiki/Monomorphization), meaning that at compile time, every time your generic type/function is used it a new copy of it is created with the type variables replaced by concrete types.

Generics are most powerful when used in combination with trait bounds, which leads me very nicely into...

## Traits ([10.2](https://doc.rust-lang.org/book/ch10-02-traits.html))

Traits define shared behaviour, and tell the compiler about what functionality a particular type has and shares with other types. They're very similar to interfaces/abstract classes in object-oriented languages, and very very similar to typeclasses in Haskell. Traits are defined as shown, with the function bodies omitted.

```rust
pub trait Summary {
    fn summarise(&self) -> String;
}
```

Other types can then implement traits as shown.

It is often useful to provide default implementations for methods of a trait, that then types can choose to override if they wish, or use the default behaviour.

Traits are used to specify bounds on generics and

Traits and generics form the backbone of the type system, and theres an awful lot you can do with them. A few examples, in descending order of "how ~~cursed~~ fancy is this:"

- Conditionally implementing methods by bounding `impl` blocks
- Associated types
- Trait objects & object safety
- `std::marker::PhantomData`
- Const generics
- `Deref` coercion
- Function traits (`Fn` vs `fn`)
- The `Sized` trait
- Interior mutability
- GATs

## References & Lifetimes ([10.3](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html))

One of Rust's selling points is that it ensures, at compile time, that all references/borrows are always valid. The compiler does this using lifetimes, which is the scope for which a reference is valid. Most of the time the compiler can do this for us, but sometimes we have to step in and help it out.

This is very unique to Rust and will feel weird to start with, but it'll really cement the ideas about borrow checking and ownership.

## Iterators ([13.2](https://doc.rust-lang.org/book/ch13-02-iterators.html))

## Closures ([13.1](https://doc.rust-lang.org/book/ch13-01-closures.html))

## Testing ([11](https://doc.rust-lang.org/book/ch11-00-testing.html))

## Further Reading

nomicon and reference links, linked lists, rest of the book, some more books

```

```

```

```

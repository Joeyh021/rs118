# Lesson 2 - `borrowck` 1-2

Today we're gonna cover ownership. This is where it will start to get confusing, but eventually it'll click and you'll see why all your C code doesn't work.

## Ownership ([4.1](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html))

Rust does not have a garbage collector like Java/Python/C#/Go. Instead, it allows you to manually manage memory, but within a set of constraints enforced by the compiler:

- Every value in Rust has a variable that is it's **owner**
- There can only be **one owner at a time**
- When the owning variable goes out of scope, the value will be **dropped**

If you're not familiar with the stack and the heap, read [this](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap) for a quick overview.

In terms of scope in rust, this can broadly be interpreted in the way that you probably think. A variable is valid from the point at which it is delcared, until the end of the current scope

```rust
{ //s not valid here, not declared yet
    let s = "string"; // s is valid from here down

}// this scope ends here, s is no longer valid
```

I'm going to use the `String` type as an example, which hopefully you have already seen. String is more complex than types we've seen or written so far, because it represents a mutable string that may vary in length. This is as oppose to **string literals**, like `s` in the example above.

The value of string literals are hardcoded into the program, meaning if you were to compile the below program, you'd find the actual values of the characters in the executable (you can use the `strings` command, probably combined with `grep`, to verify this).

```rust
fn main(){
    println!("Hello from your binary file!");
}
```

`String`, instead, stores the string data on the heap, which allows us to work with text that is unknown at compile time. `String`s can be mutated:

```rust
{
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{s}"); // This will print `hello, world!`
} // s goes out of scope here
```

Since data on the heap is being used, we need to:

- Allocate that memory when we create the string
- Modify the buffer as we grow the string
- Free the memory when we're done with it

Rust is a big fan of _zero-cost abstraction_, meaning that lots of these details that would ordinarily have to be done manually in C/C++, are abstracted away behind `String`'s implementation details. The zero-cost bit mean's its just as fast as doing it manually, so we get all this simplicity for free.

- Memory is allocated by the call to `String::new()` or `String::from()`
- The buffer is modified behind the scenes when we modify the string's size using `String::push_str()`
- The memory is **automatically freed when the owning variable goes out of scope**

This last bit is really key. Using the example above, we can see that `s` goes out of scope at the closing brace. `s` is the variable that _owns_ the string, so the as the owner goes out of scope, the memory is freed. This is done using a special function called [`drop()`](https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop), which Rust calls for us and is implemented automatically for most types.

(This concept will be familiar to you if you know about the concept of Resource Acquisition Is Initialization (RAII) in C++)

### Moves

What do you think this code does ?

```rust
let x = 5;
let y = x;
```

How about this?

```rust
let s1 = String::from("hello");
let s2 = s1;
```

The first example binds the value `5` to the variable `x`, and then the second line makes a **copy** of the variable `x` and binds it to `y`.

The second example does not do this.

`String` is a Struct made up of 3 parts:

- A number representing it's length
- A number representing the capacity of it's internal buffer
- A **pointer** to the buffer where the data is.

(For those of you not familiar with pointers, a pointer is just a number representing an address in memory. It is a variable that says something like "hello, the data you're looking for isn't here, but it can be found at this memory address!". The idea is that you then go and look at that memory address on the heap to go get your data.)

Our string looks a little something like this (the left values are on the stack, the heap to the right):

![](https://doc.rust-lang.org/book/img/trpl04-01.svg)

So to copy our data, we could copy both the heap and stack data, giving us a view in memory like this:

![](https://doc.rust-lang.org/book/img/trpl04-03.svg)

This is also not what happens (imagine if your string was very very long, this would be a very expensive operation).

So what we could do is copy only the data on the stack (the three numbers), giving us a view of the two variables that looks like this:

![](https://doc.rust-lang.org/book/img/trpl04-02.svg)

This is not what happens. Remember that when variables go out of scope, `drop()` is called and their memory is freed. If this were the case, the pointer would be freed twice, and this is a big error that can cause the heap to be corrupted.

What _actually_ happens, is that when you create a copy of the `String`, it's values are **moved**.

![](https://doc.rust-lang.org/book/img/trpl04-04.svg)

A [**shallow copy**](https://stackoverflow.com/questions/184710/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy) is made, copying only the stack data, and not the heap data. To avoid the issue of multiple pointers pointing to the same data **the old variable is invalidated**. Try to run this:

```rust
  let s1 = String::from("hello");
  let s2 = s1;

  println!("{}, world!", s1);
```

You can't, because `s1` was invalidated when you moved it into `s2`, and `s2` became the new owner.

### `Copy` and `Clone`

Of course, this wasn't the case for our first example with the integers:

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

Both variables are still valid. This is because, for certain types which are

- Small/cheap to copy
- Have a known size at compile time
- Live on the stack

Rust disregards the whole move semantics thing and just makes copies all over the place, because it is basically free to do so. This is done via the `Copy` trait, a trait that tells the compiler that the type is basically free to copy. If a type is `Copy`, then you don't have to worry about move semantics. The following types are `Copy` by default:

- All integral types, such as `u32`
- `bool` (`true`/`false`)
- Floats `f64` and `f32`
- `char`s
- Tuples, but only if they contain types that are also `Copy`.
  - `(u32,f64)` is `Copy` but `(char, String)` is not

There are other ways to make copies of data too. The `Clone` trait can be implemented on any type, which gives it a `clone()` method. `clone()` may be called explicitly to make a copy of your data. The following code clones the data in `s1` into `s2`, meaning both variables own separate copies of the data.

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

- `Clone` is used to allow types to be explicitly copied when needed, and indicates that this is an expensive operation which may take time
- `Copy` is used to tell the compiler that types may be copied for free, and that move semantics may be disregarded for this type

To learn how to add these traits to your types, see [Derivable Traits](https://doc.rust-lang.org/book/appendix-03-derivable-traits.html).

### Ownership and Functions

The semantics for passing values to functions follow the same rules, it will either move or copy, just like assigning to a variable.

```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

We can't use `s` after `take_ownership()` is called, as it is moved into the function, then the function scope ends and it is dropped.

Functions return values, which gives ownership too. Assigning the result of a function call to a variable makes that variable the new owner:

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```

## References and Borrowing ([4.2](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html))

What if we want to use a value in a function, without having to pass ownership around?

```rust

fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(s1);

    //error, s1 has been moved into calculate_length, then dropped when it went out of scope
    println!("The length of '{}' is {}.", s1, len);

}

fn calculate_length(s: String) -> usize {
    s.len()
}
```

This is where **borrowing** comes in. **References** allow us to temporarily borrow values from their owner.

```rust

fn main() {
    let mut s1 = String::from("hello");

    let len = calculate_length(&s1);

    //error, s1 has been moved into calculate_length, then dropped when it went out of scope
    println!("The length of '{}' is {}.", s1, len);

}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

The ampersand `&` in front of `String` denotes that it is a **reference type**: the parameter `s` in the function does not own the `String`, _it owns a reference to it_. References are similar to pointers, except they come with a few more restrictions and static guarantees.

- `&` in front of a type name denotes that the type is a reference to a value of that type, and does not have ownership
- `&` in front of a value creates a reference to that value (see the call site in the listing above, `&s1`)

![](https://doc.rust-lang.org/book/img/trpl04-05.svg)

When you create a reference, you are **borrowing the value**.

So, using that, try this below:

```rust
fn main() {
    let mut s = String::from("hello");

    add_world(&s);
}

fn add_world(some_string: &String) {
    some_string.push_str(", world");
}
```

Look at that compile error. You've tried to modify a value that you do not own, which is not allowed. When you create a reference, you are not allowed to modify it: **references are immutable**.

### Mutable References

I lied, you can modify values that you don't own, but you need a special kind of reference: `&mut`, the mutable reference:

```rust
fn main() {
    let mut s = String::from("hello");

    add_world(&mut s);

}

fn add_world(some_string: &mut String) {
    some_string.push_str(", world");
}
```

This works, because we told the function it could accept an `&mut String`, and then created one using `&mut s`. How about this?

```rust
fn main() {
    let mut s = String::from("hello");

    let ref_1 = &mut s;
    let ref_2 = &mut s;
    add_world(ref_1);
    add_exclamation(ref_2);
}

fn add_world(some_string: &mut String) {
    some_string.push_str(", world");
}

fn add_exclamation(some_string: &mut String){
    some_string.push_str("!");
}
```

I think the compiler is pretty clear here: **we can only have one mutable reference in scope at a time**. This is really annoying because this makes shared mutable state really hard, but for good reason. Shared mutable state is generally regarded as really bad, as it introduces loads of bugs: data races are non-existant, and theres no pointer aliasing at all. Rust will just straight up refuse to compile any of these bugs, which is very kind of it. Compare this to C, which doesn't give a shit how dumb you are, and will be even dumber in response.

You also cannot combine mutable and immutable references:

```rust
  let mut s = String::from("hello");

  let r1 = &s; // no problem
  let r2 = &s; // no problem
  let r3 = &mut s; // BIG PROBLEM

  println!("{}, {}, and {}", r1, r2, r3);
```

You can have either:

- **Any number of immutable references**
- **One mutable reference**

Remember that this all depends on scope though, and references are dropped when they leave scope or when they are last used:

```rust
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
println!("{} and {}", r1, r2);
// variables r1 and r2 will not be used after this point

let r3 = &mut s; // no problem
println!("{}", r3);
```

Rust will also not allow you to create a reference to data that **outlives the reference**:

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");
    &s
}
```

This code won't compile, because `s` goes out of scope at the end of `dangle`, so the string that it owns is dropped. This means that if you were to access the `reference_to_nothing` that `dangle` returns, it would be precisely that: a reference to something that no longer exists. `&s` would be a **dangling reference**, and Rust doesn't allow this.

The concept of [lifetimes](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html) deals with when and where references are valid, but that can get really fucky so we'll save that for another time.

## Slices ([4.3](https://doc.rust-lang.org/book/ch04-03-slices.html))

Slices are a special kind of reference, that give you a view into a **contiguous sequence of elements**. Slices allow you to refer to parts of strings, arrays, or [`Vec`s](https://doc.rust-lang.org/book/ch08-01-vectors.html). Say we want to take a string, and return the first word in it:

- We could return some indices, but this would be annoying to work with
- We could create a copy, but this would be expensive (what if the word is really long?)
- Or, we could use a slice, to return a reference to a part of the string:

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    //some fancy for loop/iterator stuff
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

The compiler will ensure that our slice of the string remains valid:

```rust
fn main() {
    let mut s = String::from("hello world");

    let word: &str = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```

This fails because `s.clear()` creates an immutable reference, which then invalidates our immutable slice in `word`, meaning we can no longer use it past that point.

### `&str`

`&str` is the string slice type, but it is also the type of string literals. Remember how string literals were stored inside the binary somewhere? Well slices allow us to refer to those immutably.

```rust
let s: &str = "Hello, World!";
let s1: &str = &s[1..3];
```

We don't own the string, but we can slice it immutably.

More detail on `String` and `&str` is available [in The Book](https://doc.rust-lang.org/book/ch08-02-strings.html). Rust uses UTF-8 encoding, so 1 byte != 1 character, and there's a fair amount of complexity associated with this.

### Array slices

You can also slice arrays:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice_1: &[i32] = &a[1..3];

let slice_2: &[i32] = &a[4..5];

```

## `Vec`s ([8.1](https://doc.rust-lang.org/book/ch08-01-vectors.html))

`Vec` are Rust's equivalent of:

- Python's List
- Java's ArrayList
- C++'s std::vec

They provide a contiguous, heap allocated, dynamically-allocated, homogenous, collection of elements.

```rust
let mut v1: Vec<i32> = Vec::new(); //a new, empty vec
let v2: Vec<&str> = Vec::from(["hello", "world"]); //create a vec from an array

//we can push
v.push(5);
v.push(6);
v.push(7);
v.push(8);

//and pop
//the vector may be empty, so this returns an option
let maybe_tail: Option<i32> = v.pop();
```

We can also index and slice into vectors.

```rust
let mut v = vec![1, 2, 3, 4, 5];
let third: &i32 = &v[2];

println!("The third element is {third}");

let mut_slice: &mut [i32] = &mut v[3..5];
mut_slice[1] +=1;

println!("The new last element is {}", mut_slice[1]);
```

Note that indexing is not a safe operation, and may panic if the index is out of bounds. We can fix this using the `get` method, which returns and `Option`.

```rust
let v = vec![1, 2, 3, 4, 5];

//will panic!
//let does_not_exist = &v[100];

match v.get(100) {
    Some(i) => println!("100th element is {i}"),
    None => println!("Looks like your index is out of bounds there buddy"),
}

match v.get(2) {
    Some(i) => println!("2nd element is {i}"),
    None => println!("Looks like your index is out of bounds there buddy"),
}
```

If you wanted to iterate over a vector, you might think of something like this:

```rust
let v = vec![100, 32, 57];
for i in 0..len(v) {
    print!("{i} ");
}
println!();
```

However, we can use iterators to do better:

```rust
let v = vec![100, 32, 57];
for elem in &v {
    print!("{elem} ");
}
println!();

```

This will iterate over an immutable reference to `v`, hence the `&v`. If we wanted to iterate over while mutating, we need a mutable iterator, which is created as you'd expect:

```rust
let v = vec![100, 32, 57];
for elem in &mut v {
    *elem+=1;
    print!("{elem} ");
}
println!();
```

Note how we have to use the **dereference** operator on elem. Dereferencing is how we access the value behind a reference. This is often done implicitly for us, but sometimes we have to do it ourselves, like here.

## The Structure of a Rust Program ([7](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html))

Using multiple files and directories to organise your code is very important as projects grow, and the way this is done in Rust is built into Cargo and the language.

- A **crate** is a single compilation unit in rust
  - Crates group related functionality
  - Crates have a **crate root**
    - `main.rs` for an executable
    - `lib.rs` for a library
- **Modules** are used to organise code within a crate
  - Modules are nested to create a module tree

Say for example we have a library crate that provides some functionality for a restaurant. We can use the `mod` keyword to create sub-modules within a single file:

```rust,noplayground
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

which creates a structure like this

```
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

We can then use paths to refer to items in the module tree:

- An absolute path starts from the crate root using either the crate name, or `crate::`
- A relative path starts from the current module
  - The `self` identifier refers to the current module
    - Like `.` in a filesystem path
  - The `super` identifier refers to the parent module
    - Like `..` in a filesystem path

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

This example won't compile, for another reason. Everything within a module, including submodules, is **private by default**. If you want to expose a module, function, or type within a module, you need to mark it with the `pub` keyword:

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

You can also bring paths into scope using the `use` keyword, which means you don't have to write out massively long paths every time

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
```

This is how items within the standard library are typically used

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

The `use` keyword can also be used to re-export items:

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```

This not only brings the item into scope for the current module, but also allows exports the item as publicly available for parent modules to use.

### Modules in Separate Files

Putting submodules in the same file is generally not done, except for very specific use cases. The other way to create modules is to put each one in it's own file, and then include those modules in your crate root using `mod filename;`. Say we had the following crate structure:

```
.
├── Cargo.toml
└── src
    ├── main.rs
    ├── submod_1.rs
    └── submod_2.rs
```

We could then do the following

```rust
mod submod_1;
pub mod submod_2;
fn main(){
    submod_1::foo();
    submod_2::bar();
}

```

- `submod_1` is imported and re-exported
- `submod_2` is just imported

We can also use `mod.rs` files to make directories appear as a single module. Say we extend our example from above:

```
.
├── Cargo.toml
└── src
    ├── main.rs
    ├── submod_1.rs
    ├── submod_2.rs
    └── submod_3
        ├── mod.rs
        ├── subsubmod_1.rs
        └── subsubmod_2.rs
```

```rust
mod submod_3;
fn main(){
    submod_1::foo();
    submod_2::bar();
}
```

Including `submod_3` includes `mod.rs`, and whatever items that module may export (probably some items from `subsubmod_1.rs`, `subsubmod_2.rs`). Structuring a crate well and maintaining control over what items are visible where (encapsulation) is key to writing good, maintainable rust code. This section is just an overview, so be sure to check [Rust by Example](https://doc.rust-lang.org/rust-by-example/mod.html) for more examples to help understand the concept.
